/****************************************************************************** 

  (c) 2017 Scientific Computation Research Center, 
      Rensselaer Polytechnic Institute. All rights reserved.
  
  This work is open source software, licensed under the terms of the
  BSD license as described in the LICENSE file in the top-level directory.
 
*******************************************************************************/
#ifndef MSI_HEADER_H
#define MSI_HEADER_H
#include "pumi.h"

extern pOwnership msi_ownership=NULL;

enum msi_matrix_type { /*0*/ MSI_MULTIPLY=0, 
                       /*1*/ MSI_SOLVE}; 
enum msi_matrix_status { /*0*/ MSI_NOT_FIXED=0,
                         /*2*/ MSI_FIXED};

// remember to delete ownership 
void msi_setOwnership(pMesh m, pOwnership o);

// these functions rely on global ID generated by pumi_mesh_createGlobalID
void msi_ment_getLocalFieldID(pMeshEnt e, pField f, int* start_id, int* end_id_plus_one);
void msi_ment_getGlobalFieldID(pMeshEnt e, pField f, int* start_id, int* end_id_plus_one);

int msi_field_getNumOwnDOF(pField f);
void msi_field_getOwnDOFID (pField f, int*, int*);

#ifdef MSI_PETSC
/** matrix and solver functions with PETSc */
void msi_matrix_create(int matrix_id, int matrix_type, pField f); //zerosuperlumatrix_
void msi_matrix_freeze(int matrix_id); //finalizematrix_
void msi_matrix_delete(int matrix_id); //deletematrix_

void msi_matrix_insert(int matrix_id, int row, int column, double* val);
void msi_matrix_add(int matrix_id, int row, int column, double* val); //globalinsertval_
void msi_matrix_addBlock(int matrix_id, pMeshEnt, int rowVarIdx, int columnVarIdx, double* values);

void msi_matrix_setbc(int matrix_id, int row);
void msi_matrix_setlaplacebc (int matrix_id, int row, int numVals, int* columns, double* values);

void msi_matrix_solve(int matrix_id, pField x_field, pField b_field); 
int msi_matrix_getiternum(int matrix_id);
void msi_matrix_multiply(int matrix_id, pField, pField); 
void msi_matrix_flush(int matrix_id);

// for performance test
void msi_matrix_write(int matrix_id, const char* file_name, int start_index);
void msi_matrix_print(int matrix_id);
#endif // #ifdef MSI_PETSC

#ifdef MSI_TRILINOS
//=========================================================================
/** matrix and solver functions with TRILINOS */
//=========================================================================

int msi_epetra_create(int matrix_id, int matrix_type, int field_id);
int msi_epetra_delete(int matrix_id);

int msi_epetra_insert(int matrix_id, int row, int column, double* val);
int msi_epetra_addblock(int matrix_id, int * ielm, int rowVarIdx, int * columnVarIdx, double * values);

int msi_epetra_setbc(int matrix_id, int row);
int msi_epetra_setlaplacebc (int * matrix_id, int *row, int * numVals, int *columns, double * values);
int msi_epetra_freeze(int matrix_id); 
int msi_epetra_multiply(int matrix_id, int in_fieldid, int out_fieldid);
int msi_epetra_write(int matrix_id, const char*, int skip_zero, int start_index);
int msi_epetra_print(int matrix_id);

int msi_solver_aztec(int matrix_id, int x_fieldid, int
		       b_fieldid, int num_iter, double* tolerance,
		       const char* krylov_solver, const char*
		       preconditioner, const char* sub_dom_solver,
		       int overlap, int graph_fill, double*
		       ilu_drop_tol,  double* ilu_fill,
		       double* ilu_omega, int poly_ord);
  
int msi_solver_getnumiter(int matrix_id, int * iter_num);
#endif //#ifdef MSI_TRILINOS
#endif
